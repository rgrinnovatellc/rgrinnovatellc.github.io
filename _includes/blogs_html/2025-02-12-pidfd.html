<title>The power of pidfd</title>
<h2 id="problem-pid-reuse-can-cause-supervisor-confusion">Problem: PID Reuse Can Cause Supervisor Confusion</h2>
<p>In a traditional PID-based system, the supervisor <strong>tracks processes by their PID</strong>, leading to potential <strong>race conditions</strong>:</p>
<ol>
<li><strong>Supervisor starts a worker process</strong> (e.g., PID = <code>1234</code>).</li>
<li><strong>Worker dies unexpectedly</strong> (needs a restart).</li>
<li><strong>Kernel marks PID = <code>1234</code> as available</strong> for reuse.</li>
<li><strong>A new, unrelated process spawns</strong> and gets <strong>PID = <code>1234</code></strong>.</li>
<li><strong>Supervisor checks for PID <code>1234</code></strong>, sees it exists, and <strong>mistakenly assumes the worker is still running</strong>.</li>
<li><strong>Supervisor does nothing</strong> (doesnâ€™t restart the worker) â†’ <strong>Bug!</strong></li>
</ol>
<hr>
<h2 id="solution-pidfd-ensures-stable-process-tracking">âœ… Solution: <code>pidfd</code> Ensures Stable Process Tracking</h2>
<p>With <code>pidfd</code>, the supervisor <strong>tracks the worker using a stable file descriptor</strong>, instead of relying on PIDs.</p>
<h3 id="how-pidfd-works-to-prevent-this-bug">ðŸ”¹ How <code>pidfd</code> Works to Prevent This Bug</h3>
<ol>
<li><strong>Supervisor creates a worker process</strong> (e.g., PID <code>1234</code>).</li>
<li><strong>Supervisor opens a <code>pidfd</code> for the worker</strong> (<code>pidfd = 5</code>).<ul>
<li><code>pidfd</code> is a <strong>stable reference</strong> to the worker process.</li>
<li>Unlike PIDs, <code>pidfd</code> <strong>remains unique and cannot be reused</strong>.</li>
</ul>
</li>
<li><strong>Worker dies unexpectedly.</strong>  <ul>
<li>The <strong>PID <code>1234</code> is freed</strong> by the kernel.  </li>
<li>The <strong><code>pidfd = 5</code> is automatically marked as invalid by the pidfd layer</strong>.  </li>
<li>Any future operations on this pidfd (like pidfd_send_signal() or waitid()) will fail with ESRCH (No such process).</li>
<li>The supervsior (e.g., systemd or user-space processes such as kubernetes controller) monitors the pidfs using poll() or epoll()</li>
</ul>
</li>
<li><strong>A new, unrelated process spawns and gets PID <code>1234</code>.</strong>  <ul>
<li><strong>The new process has no relation to the old <code>pidfd = 5</code></strong>.</li>
</ul>
</li>
<li><strong>Supervisor checks <code>pidfd = 5</code></strong>:  <ul>
<li><strong>Finds that it is closed</strong> â†’ It knows the worker is truly gone.  </li>
<li>The supervsior monitors the pidfs using poll() or epoll(). </li>
<li>The pidfd becomes readable, it means the old process has exited. </li>
<li>The supervisor knows the status and close the pidfd using close(pidfd).</li>
</ul>
</li>
<li><strong>Supervisor restarts the worker process correctly with a new pid, and of course with new pidfd</strong></li>
</ol>
<h7 id="note-holding-pidfd-dosesnt-mean-holding-pid-once-the-process-dies-the-pidfd-is-marked-as-referring-to-a-non-existent-process-invalid"><strong>Note</strong>: Holding pidfd dosesn&#39;t mean holding pid. Once the process dies, the pidfd is marked as referring to a non-existent process (invalid).  </h7>
<h3 id="detailed-breakdown-of-pidfd-behavior">Detailed Breakdown of <code>pidfd</code> Behavior</h3>
<table>
<thead>
<tr>
<th>Event</th>
<th>PID-Based Tracking (Buggy)</th>
<th><code>pidfd</code>-Based Tracking (Correct)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Worker starts</strong></td>
<td>Supervisor tracks PID <code>1234</code>.</td>
<td>Supervisor gets <code>pidfd = 5</code>.</td>
</tr>
<tr>
<td><strong>Worker dies</strong></td>
<td>Kernel frees PID <code>1234</code>.</td>
<td><code>pidfd = 5</code> is marked invalid.</td>
</tr>
<tr>
<td><strong>New process spawns with PID <code>1234</code></strong></td>
<td>Supervisor mistakenly thinks worker is still running.</td>
<td>Supervisor correctly detects worker death using <code>pidfd</code>.</td>
</tr>
<tr>
<td><strong>Supervisor check</strong></td>
<td>Sees PID <code>1234</code> exists â†’ No restart.</td>
<td>Sees <code>pidfd = 5</code> is closed â†’ Restarts worker.</td>
</tr>
</tbody></table>
<hr>
<h2 id="why-pidfd-is-powerful"> Why <code>pidfd</code> is Powerful</h2>
<ul>
<li><strong>Stable Reference:</strong> Unlike PIDs, <code>pidfd</code> <strong>cannot be reused</strong> by another process.  </li>
<li><strong>No Race Conditions:</strong> Ensures that the supervisor always <strong>knows when a worker dies</strong>.  </li>
<li><strong>Safer Process Management:</strong> Prevents misidentifying processes due to PID reuse.</li>
</ul>
<h3 id="max-value-of-pid-vs-pidfd">Max. value of pid vs. pidfd</h3>
<p>In 32-bit system, we can have /proc/sys/kernel/pid_max value 32768, but in 64-bit, it is 4194304. And we can change the value of pidfd using <code>ulimit -n</code> and <code>ulimit -Hn</code>.</p>
<p>When a process exits, its exit code and status (e.g., whether it was killed by a signal) are stored in the kernel, and the parent process can retrieve this status only once using wait(), waitpid(), or waitid(). After a successful wait() (or its variants), the kernel cleans up the processâ€™s status, fully reaping and removing it from the system, meaning any further calls to wait() on that PID will fail because the process no longer exists. A pidfd allows referring to a process safely and race-free, but it does not change the &quot;at-most-once&quot; rule of wait(). If another thread or process has already waited on and reaped the process, calling waitid() on pidfd will fail since the exit status is gone, though the pidfd itself remains valid but cannot retrieve the exit status again.</p>
